<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Clojure 实战(1)：使用 Noir 框架开发博客(上) | 张吉的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言为什么要学习一门新的语言？我的想法很简单，平时OO、PO代码写多了，却从未接触过函数式编程，不免有些遗憾。考察下来，Clojure可以用来尝尝鲜，所以就决定学一学。为了给自己的学习留下些记录，就有了这样一份教程。 Clojure已经有一些不错的教程，如Mark Volkmann的Clojure - Functional Programming for the JVM，Storm的主要贡献者徐明">
<meta name="keywords" content="clojure,noir,tutorial">
<meta property="og:type" content="article">
<meta property="og:title" content="Clojure 实战(1)：使用 Noir 框架开发博客(上)">
<meta property="og:url" content="http://shzhangji.com/cnblogs/2012/11/25/cia-noir-1/index.html">
<meta property="og:site_name" content="张吉的博客">
<meta property="og:description" content="前言为什么要学习一门新的语言？我的想法很简单，平时OO、PO代码写多了，却从未接触过函数式编程，不免有些遗憾。考察下来，Clojure可以用来尝尝鲜，所以就决定学一学。为了给自己的学习留下些记录，就有了这样一份教程。 Clojure已经有一些不错的教程，如Mark Volkmann的Clojure - Functional Programming for the JVM，Storm的主要贡献者徐明">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-09-30T23:07:36.293Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Clojure 实战(1)：使用 Noir 框架开发博客(上)">
<meta name="twitter:description" content="前言为什么要学习一门新的语言？我的想法很简单，平时OO、PO代码写多了，却从未接触过函数式编程，不免有些遗憾。考察下来，Clojure可以用来尝尝鲜，所以就决定学一学。为了给自己的学习留下些记录，就有了这样一份教程。 Clojure已经有一些不错的教程，如Mark Volkmann的Clojure - Functional Programming for the JVM，Storm的主要贡献者徐明">
<meta name="twitter:creator" content="@zjerryj">
<link rel="publisher" href="zhangji87@gmail.com">
  
    <link rel="alternate" href="/cnblogs/atom.xml" title="张吉的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link rel="stylesheet" href="/cnblogs/css/source-code-pro.css">
  
  <link rel="stylesheet" href="/cnblogs/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-37223379-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/cnblogs/" id="logo">张吉的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/cnblogs/" id="subtitle">If I rest, I rust.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/cnblogs/">首页</a>
        
          <a class="main-nav-link" href="/cnblogs/categories/Big-Data">大数据</a>
        
          <a class="main-nav-link" href="/cnblogs/categories/Programming">编程</a>
        
          <a class="main-nav-link" href="/cnblogs/categories/Digest">摘译</a>
        
          <a class="main-nav-link" href="/cnblogs/archives">全部文章</a>
        
          <a class="main-nav-link" href="http://shzhangji.com/">English</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/cnblogs/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://shzhangji.com/cnblogs"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-cia-noir-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/cnblogs/2012/11/25/cia-noir-1/" class="article-date">
  <time datetime="2012-11-25T08:58:00.000Z" itemprop="datePublished">2012-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/cnblogs/categories/Programming/">Programming</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Clojure 实战(1)：使用 Noir 框架开发博客(上)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么要学习一门新的语言？我的想法很简单，平时OO、PO代码写多了，却从未接触过函数式编程，不免有些遗憾。考察下来，Clojure可以用来尝尝鲜，所以就决定学一学。为了给自己的学习留下些记录，就有了这样一份教程。</p>
<p>Clojure已经有一些不错的教程，如<a href="http://java.ociweb.com/mark/" target="_blank" rel="noopener">Mark Volkmann</a>的<a href="http://java.ociweb.com/mark/clojure/article.html" target="_blank" rel="noopener">Clojure - Functional Programming for the JVM</a>，Storm的主要贡献者<a href="http://xumingming.sinaapp.com/" target="_blank" rel="noopener">徐明明</a>也对这个教程做了<a href="http://xumingming.sinaapp.com/302/clojure-functional-programming-for-the-jvm-clojure-tutorial/" target="_blank" rel="noopener">全文翻译</a>。还有一些不错的书籍，像<a href="http://oreilly.com/" target="_blank" rel="noopener">O’Reilly</a>的<a href="http://www.amazon.com/Clojure-Programming-Chas-Emerick/dp/1449394701" target="_blank" rel="noopener">Clojure Programming</a>，都值得一读。我是从Mark的教程开始学起的，对其中没有提到的部分则是参考了Clojure Programming这本书。Clojure的<a href="http://clojure.org/" target="_blank" rel="noopener">官方网站</a>上有详尽的<a href="http://clojure.github.com/clojure/" target="_blank" rel="noopener">API参考</a>，可以作为工具书查阅。</p>
<p>但是，上面提到的教程都是针对Clojure语言本身的，从 <em>Hello, world!</em> 开始，讲解Clojure的各种语法，关键字，结构等等。虽然Clojure的语法已经足够吸引你的眼球，在<a href="http://en.wikipedia.org/wiki/Read-eval-print_loop" target="_blank" rel="noopener">REPL</a>中敲击Clojure代码已经是一种莫大的乐趣了，但似乎还有些不够，我们想看到一个用Clojure编写的应用程序！</p>
<p>因为平时都是做Web开发，所以先从一个Web框架入手会是不错的选择，因此这份教程会从使用<a href="http://webnoir.org/" target="_blank" rel="noopener">Noir</a>框架搭建一个博客开始，带你领略Clojure的魅力。</p>
<a id="more"></a>
<h2 id="一句话概述Clojure"><a href="#一句话概述Clojure" class="headerlink" title="一句话概述Clojure"></a>一句话概述Clojure</h2><p><strong>Clojure是一种运行在JVM平台上的函数式编程语言。</strong></p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Jvm" target="_blank" rel="noopener">JVM平台</a>：历史悠久，应用广泛，成熟稳定。Clojure可以和Java程序交互，调用各种类库，与现有系统整合。</li>
<li><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">函数式编程</a>：<a href="http://en.wikipedia.org/wiki/LISP" target="_blank" rel="noopener">Lisp</a>的一种方言，表达力强，是解决高并发问题的利器。</li>
</ul>
<h2 id="安装Clojure"><a href="#安装Clojure" class="headerlink" title="安装Clojure"></a>安装Clojure</h2><p>Clojure是以一个Jar包发行的，可以到<a href="http://clojure.org/getting_started" target="_blank" rel="noopener">官网下载</a>后使用<code>java -jar</code>命令运行。而在实际开发中，我们会选择使用<a href="https://github.com/technomancy/leiningen" target="_blank" rel="noopener">Leiningen</a>或<a href="http://maven.apache.org/" target="_blank" rel="noopener">Maven</a>来管理Clojure项目，本教程将以Leiningen（命令行是<code>lein</code>）作为项目管理工具进行讲解。</p>
<h3 id="安装Leiningen"><a href="#安装Leiningen" class="headerlink" title="安装Leiningen"></a>安装Leiningen</h3><p><code>lein</code>目前有1.x和2.x两个版本，后者还在alpha阶段。使用以下命令安装<code>lein</code> 1.x版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/bin <span class="comment"># 假设$HOME/bin目录在系统的$PATH中</span></span><br><span class="line">$ wget https://raw.github.com/technomancy/leiningen/stable/bin/lein</span><br><span class="line">$ chmod 755 lein</span><br><span class="line">$ lein self-install</span><br><span class="line">$ lein repl</span><br><span class="line">REPL started; server listening on localhost port 1096</span><br><span class="line">user=&gt;</span><br></pre></td></tr></table></figure>
<p>这样就已经安装好了<code>lein</code>和Clojure环境，并启动了一个REPL，可以直接运行Clojure代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (+ 1 2)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">user=&gt;</span><br></pre></td></tr></table></figure>
<p>这里出现了Clojure的两个特点：圆括号和前缀表达式。Clojure的基本语法是<code>(fn1 arg1 (fn2 arg2 arg3))</code>。函数是Clojure中的“一等公民”，它即是可执行的代码，又是一种数据（类似闭包的概念）。以后我们会慢慢熟悉。</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ lein new proj</span><br><span class="line">$ find proj</span><br><span class="line">proj</span><br><span class="line">proj/project.clj</span><br><span class="line">proj/src/proj/core.clj</span><br><span class="line">$ cat proj/project.clj</span><br><span class="line">(defproject proj <span class="string">"1.0.0-SNAPSHOT"</span></span><br><span class="line">  :description <span class="string">"FIXME: write description"</span></span><br><span class="line">  :dependencies [[org.clojure/clojure <span class="string">"1.3.0"</span>]])</span><br></pre></td></tr></table></figure>
<p><code>lein new</code>命令用来创建一个Clojure项目骨架，最重要的文件是<code>project.clj</code>，它声明了项目的基本属性以及依赖包。</p>
<p><code>lein plugin</code>命令可以用来管理lein的插件，我们可以通过安装lein-noir插件来生成基于Noir的项目骨架：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ lein plugin install lein-noir 1.2.1</span><br><span class="line">$ lein noir new blog</span><br><span class="line">$ find blog</span><br><span class="line">blog</span><br><span class="line">blog/project.clj</span><br><span class="line">blog/resources/public/css/reset.css</span><br><span class="line">blog/resources/public/img</span><br><span class="line">blog/resources/public/js</span><br><span class="line">blog/src/blog/models</span><br><span class="line">blog/src/blog/server.clj</span><br><span class="line">blog/src/blog/views/common.clj</span><br><span class="line">blog/src/blog/views/welcome.clj</span><br></pre></td></tr></table></figure>
<p>我们可以直接运行这个项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ lein run</span><br><span class="line">Starting server...</span><br><span class="line">2012-11-29 22:34:39.174:INFO::jetty-6.1.25</span><br><span class="line">2012-11-29 22:34:39.237:INFO::Started SocketConnector@0.0.0.0:8080</span><br></pre></td></tr></table></figure>
<p>浏览<a href="http://localhost:8080，就能看到项目的页面了。" target="_blank" rel="noopener">http://localhost:8080，就能看到项目的页面了。</a></p>
<h2 id="Noir项目的基本结构"><a href="#Noir项目的基本结构" class="headerlink" title="Noir项目的基本结构"></a>Noir项目的基本结构</h2><h3 id="项目基本信息：project-clj"><a href="#项目基本信息：project-clj" class="headerlink" title="项目基本信息：project.clj"></a>项目基本信息：project.clj</h3><p>Clojure文件都是以<code>.clj</code>为扩展名的。项目根目录下的project.clj文件包含了一些基本信息，我们逐一分析：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defproject</span> blog <span class="string">"0.1.0-SNAPSHOT"</span></span><br><span class="line">            <span class="symbol">:description</span> <span class="string">"FIXME: write this!"</span></span><br><span class="line">            <span class="symbol">:dependencies</span> [[org.clojure/clojure <span class="string">"1.3.0"</span>]</span><br><span class="line">                           [noir <span class="string">"1.2.1"</span>]]</span><br><span class="line">            <span class="symbol">:main</span> blog.server)</span><br></pre></td></tr></table></figure>
<p><a href="http://clojuredocs.org/leiningen/leiningen.core/defproject" target="_blank" rel="noopener">defproject</a>是Leiningen定义的一个<a href="http://clojure.org/macros" target="_blank" rel="noopener">宏</a>，用来描述项目的基本信息。宏在Clojure中是一个很重要的语言特性，简单地说，开发者可以用宏创造出新的语法。</p>
<p>:description、:main等是一种直接量(literal)，我们称之为关键字(keyword)，通常以<code>:</code>开头，主要用来作为哈希表(map)中的键名，这里则用来表示项目的某种信息，从名称上应该很好理解。</p>
<p><code>[1 [&quot;b&quot;, false]]</code>中的<code>[...]</code>表示一个向量(vector)，它的元素可以是任意类型，元素之间以空格或逗号分隔。这行代码也展示了Clojure中其他几种直接量：数值型、字符串、布尔型。</p>
<p>依赖项的描述也很直观，<code>[groupId/artifactId &quot;version&quot;]</code>。Clojure使用了和Maven相似的包命名方式，当groupId和artifactId相同时，可以进行简写，如<code>[noir &quot;1.2.1&quot;]</code>等价于<code>[noir/noir &quot;1.2.1&quot;]</code>，这也是Clojure鼓励的做法。对依赖项进行修改后，可以运行<code>lein deps</code>命令进行安装。lein会先从<a href="https://clojars.org" target="_blank" rel="noopener">Clojars</a>上查找和下载，不存在时再到<a href="http://search.maven.org/" target="_blank" rel="noopener">Maven中央仓库</a>中搜索。</p>
<p>最后，:main顾名思义指向的是程序入口，它配置的是一个命名空间，其中会包含一个<code>-main</code>方法（注意方法名中的<code>-</code>）。Leiningen项目的目录结构也是按照命名空间来的，这点和Java一致。</p>
<h3 id="入口文件：src-blog-server-clj"><a href="#入口文件：src-blog-server-clj" class="headerlink" title="入口文件：src/blog/server.clj"></a>入口文件：src/blog/server.clj</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> blog.server</span><br><span class="line">  (<span class="symbol">:require</span> [noir.server <span class="symbol">:as</span> server]))</span><br><span class="line"></span><br><span class="line">(<span class="name">server/load-views</span> <span class="string">"src/blog/views/"</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> -main [&amp; m]</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [mode (<span class="name"><span class="builtin-name">keyword</span></span> (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">first</span></span> m) <span class="symbol">:dev</span>))</span><br><span class="line">        port (<span class="name">Integer.</span> (<span class="name"><span class="builtin-name">get</span></span> (<span class="name">System/getenv</span>) <span class="string">"PORT"</span> <span class="string">"8080"</span>))]</span><br><span class="line">    (<span class="name">server/start</span> port &#123;<span class="symbol">:mode</span> mode</span><br><span class="line">                        <span class="symbol">:ns</span> 'blog&#125;)))</span><br></pre></td></tr></table></figure>
<p>ns宏用于定义当前的命名空间，:require表示导入其它命名空间，:as则是将为导入的命名空间设置别名。注意这些关键字及其用法都是在ns宏中定义的，这也是为什么说宏可以用来创造新的语法。</p>
<p>关于命名空间，你在执行<code>lein repl</code>的时候可能会注意到，当在blog项目下执行时，提示符是<code>blog.server=&gt;</code>，而在其他目录下执行时是<code>user=&gt;</code>，因为user是Clojure默认的命名空间，可以通过<code>(ns myspace)</code>来切换成<code>myspace=&gt;</code>。</p>
<p><code>server/load-views</code>表示调用<code>server</code>命名空间下的<code>load-views</code>函数，后面的<code>src/blog/views/</code>则是函数的参数。在大多数语言中，函数名称不能包含特殊字符，如<code>-</code>，但Clojure中的变量名、函数名、关键字等都可以包含诸如*、+、!、&gt;这样的特殊字符。其中一些字符是有特定含义的，如关键字必须以<code>:</code>开头，以<code>::</code>开头的则表示仅在当前命名空间中有效。这些约定需要注意。</p>
<p>defn宏用来定义一个函数，基本用法是<code>(defn 函数名 [参数列表] 语句1 语句2)</code>。如果参数数量不定，可以使用这样的语法<code>[arg1 arg2 &amp; args]</code>，这样当函数接收四个参数时，后两个参数会作为一个向量赋值给args变量。</p>
<p>关于let，它是继“宏”和“函数”之后出现的第三个术语，“特殊形式”(Special Form)。我们暂时不去了解它们之间的关系，先来看看let的作用。设想这样一个场景，我们在调用一个函数之前会准备一些参数传送给它，这些参数仅在函数内部可见，函数处理完后就会销毁。let则是将参数准备和函数调用这两步整合了起来。它的语法是<code>(let [变量1 表达式1 变量2 表达式2] 语句1 语句2)</code>，举例来说，尝试在REPL中执行以下命令，思考一下结果是如何得出的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (let [x 1 y (+ 2 3)] (+ x y))</span><br><span class="line"><span class="number">6</span></span><br><span class="line">user=&gt;</span><br></pre></td></tr></table></figure>
<p>入口文件中的表达式看起来有些复杂，但逐步拆解后就会明白：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (def m []) ; 定义一个变量，它是一个空向量，正如不带参数调用-main函数时一样。Clojure中分号表示注释。</span><br><span class="line">user=&gt; (first m) ; 获取向量（序列）的第一个元素，这里为空。</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">user=&gt; (or (first m) :dev) ; 从左往右执行参数，若结果不为空(nil)则停止执行，并返回该结果。</span><br><span class="line"><span class="symbol">:dev</span></span><br><span class="line">user=&gt; (keyword (or (first m) :dev)) ; 获取关键字。由于传入的参数可能是一个关键字、一个变量、或一个字符串，因此使用keyword函数返回一个关键字类型。</span><br><span class="line"><span class="symbol">:dev</span></span><br></pre></td></tr></table></figure>
<p>经过处理，mode变量包含了:dev这个关键字，且作用域仅在(let …)中有效。</p>
<p>再来看看port变量，这里涉及到了与Java类的交互：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (System/getenv) ; 这里的System不是一个命名空间，而是Java的一个类。通过这种方式我们调用了System类的静态方法getenv，并返回了一个Map类实例。</span><br><span class="line">java.util.Collections$UnmodifiableMap</span><br><span class="line">user=&gt; (get (System/getenv) "PORT" "8080") ; 这里的get不是Map实例的get方法，而是Clojure中的一个函数，用于返回哈希表(map)中的值，不存在则返回一个默认值。</span><br><span class="line"><span class="string">"8080"</span></span><br><span class="line">user=&gt; (.get (System/getenv) "PORT") ; 这才是调用Map实例的get方法，注意点号和函数的参数。</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">user=&gt; (Integer. (get (System/getenv) "PORT" "8080")) ; 又是一个和Java交互的语法：创建实例。它和以下语法等价：</span><br><span class="line"><span class="number">8080</span></span><br><span class="line">user=&gt; (new Integer (get (System/getenv) "PORT" "8080"))</span><br><span class="line"><span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>关于map再补充一点，它虽然是Clojure的一种数据类型，但底层其实是Map接口一个实现，因此以下语法是合法的。类似的情况在Clojure中还有很多。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (def m &#123;:a 1, :b 2&#125;) ; map的语法是&#123;键1 值1 键2 值2&#125;，为了加强可读性，这里使用了逗号分隔了两组键值，Clojure在编译时会将逗号转换成空格。</span><br><span class="line">user=&gt; (&lt; (get m :a) (.get m :b)) ; 1 &lt; 2</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>参数的赋值就结束了，后面的代码也很好理解：调用server命名空间下的start函数，参数是监听端口和一组由map表示的参数。这里blog之前的单引号需要注意，表示其后的代码不需要进行解析(evaluate)，在表示命空间名时都需要加上（ns宏除外），如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (require 'noir.server) ; 引入一个命名空间，使用noir.server/start调用方法。</span><br><span class="line">user=&gt; (alias 'server 'noir.server) ; 设置别名。</span><br><span class="line">user=&gt; (refer 'noir.server) ; 将该命名空间下的变量导入当当前命名空间中，即可以直接使用(start ...)调用。</span><br><span class="line">user=&gt; (use 'noir.server) ; 同时完成require和refer。</span><br></pre></td></tr></table></figure>
<p><strong>小贴士</strong></p>
<p>这一节中我们引入了不少Clojure的函数、宏、特殊形式，有时会需要查阅这些函数的用法。除了上网查找API文档，还可以在REPL中使用<code>doc</code>和<code>source</code>函数来返回某个函数或宏的文档和源码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (doc first)</span><br><span class="line">-------------------------</span><br><span class="line">clojure.core/first</span><br><span class="line">([coll])</span><br><span class="line">  Returns the first item in the collection. Calls seq on its</span><br><span class="line">    argument. If coll is nil, returns nil.</span><br></pre></td></tr></table></figure>
<h3 id="基本页面：src-blog-views-welcome-clj"><a href="#基本页面：src-blog-views-welcome-clj" class="headerlink" title="基本页面：src/blog/views/welcome.clj"></a>基本页面：src/blog/views/welcome.clj</h3><p>入口文件中的<code>load-views</code>函数会将指定目录下的所有文件都包含进来，这些文件中定义的是URL路由以及页面内容，以welcome.clj为例：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> blog.views.welcome</span><br><span class="line">  (<span class="symbol">:require</span> [blog.views.common <span class="symbol">:as</span> common]</span><br><span class="line">            [noir.content.getting-started])</span><br><span class="line">  (<span class="symbol">:use</span> [noir.core <span class="symbol">:only</span> [defpage]]</span><br><span class="line">        [hiccup.core <span class="symbol">:only</span> [html]]))</span><br><span class="line"></span><br><span class="line">(<span class="name">defpage</span> <span class="string">"/welcome"</span> []</span><br><span class="line">         (<span class="name">common/layout</span></span><br><span class="line">           [<span class="symbol">:p</span> <span class="string">"Welcome to blog"</span>]))</span><br></pre></td></tr></table></figure>
<p>我们先跳过这些代码，来看看如何定义一个新的页面。将以下代码添加到welcome.clj尾部，然后执行<code>lein run</code>。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defpage</span> <span class="string">"/greeting"</span> []</span><br><span class="line">         (<span class="name">html</span></span><br><span class="line">           [<span class="symbol">:h1</span> <span class="string">"Hello, world!"</span>]))</span><br></pre></td></tr></table></figure>
<p>访问 <a href="http://127.0.0.1:8080/greeting" target="_blank" rel="noopener">http://127.0.0.1:8080/greeting</a> 就能看到一个新的页面了，页面源码是<code>&lt;h1&gt;Hello, world!&lt;/h1&gt;</code>。</p>
<p>defpage是Noir的一个宏，用来定义URL和它返回的页面内容。URL的定义有很多其他用法，如POST方式、截取参数等，我们稍后都会用到。页面内容方面，可以直接返回字符串，如<code>(defpage &quot;/greeting&quot; [] &quot;Hello, world!&quot;)</code>，也可以使用Hiccup构建HTML页面。<a href="https://github.com/weavejester/hiccup" target="_blank" rel="noopener">Hiccup</a>是Noir默认的模板引擎，简单来说就是用Clojure来写HTML。一个完整的页面示例如下：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> ...</span><br><span class="line">  (<span class="symbol">:use</span> ...</span><br><span class="line">        [hiccup.page-helpers <span class="symbol">:only</span> [html4]]))</span><br><span class="line"></span><br><span class="line">(<span class="name">defpage</span> <span class="string">"/greeting"</span> []</span><br><span class="line">         (<span class="name">html4</span></span><br><span class="line">           [<span class="symbol">:head</span></span><br><span class="line">             [<span class="symbol">:title</span> <span class="string">"Greeting"</span>]]</span><br><span class="line">           [<span class="symbol">:body</span></span><br><span class="line">             [<span class="symbol">:h1</span> <span class="string">"Hello, world!"</span>]]))</span><br></pre></td></tr></table></figure>
<p>生成的HTML是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Greeting<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，html和html4都是Hiccup定义的宏。html仅将接收到的参数转换为HTML代码，html4则是会添加相应版本的<code>&lt;!DOCTYPE&gt;</code>和<code>&lt;html&gt;</code>标签。要使用这些宏需要引入相应的命名空间。:only则表示只引入命名空间中特定的宏。</p>
<p>关于命名空间中出现的<code>-</code>，Clojure在编译时会自动转换成<code>_</code>，从而确保程序在JVM中运行时不会出现问题。</p>
<h3 id="页面模板：src-blog-views-common-clj"><a href="#页面模板：src-blog-views-common-clj" class="headerlink" title="页面模板：src/blog/views/common.clj"></a>页面模板：src/blog/views/common.clj</h3><p>回到系统生成的welcome.clj文件，它并没有使用html或html4，而是调用了一个<code>common/layout</code>函数。那么让我们看看common.clj中这个函数的定义：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> blog.views.common</span><br><span class="line">  (<span class="symbol">:use</span> [noir.core <span class="symbol">:only</span> [defpartial]]</span><br><span class="line">        [hiccup.page-helpers <span class="symbol">:only</span> [include-css html5]]))</span><br><span class="line"></span><br><span class="line">(<span class="name">defpartial</span> layout [&amp; content]</span><br><span class="line">            (<span class="name">html5</span></span><br><span class="line">              [<span class="symbol">:head</span></span><br><span class="line">               [<span class="symbol">:title</span> <span class="string">"blog"</span>]</span><br><span class="line">               (<span class="name">include-css</span> <span class="string">"/css/reset.css"</span>)]</span><br><span class="line">              [<span class="symbol">:body</span></span><br><span class="line">               [<span class="symbol">:div#wrapper</span></span><br><span class="line">                content]]))</span><br></pre></td></tr></table></figure>
<p>defpartial是Noir的一个宏，用来定义一段可复用的HTML代码。当然我们也可以将其定义为一个函数（用<code>defn</code>替换掉<code>defpartial</code>），不会有什么区别。官方文档的解释是使用defpartial会比较容易辨认。</p>
<p><code>include-css</code>是一个函数，用来生成<code>&lt;link&gt;</code>标签。<code>[:div#wrapper ...]</code>会生成<code>&lt;div id=&quot;wrapper&quot;&gt;...&lt;/div&gt;</code>。更多Hiccup的语法可以到<a href="http://www.webnoir.org/tutorials/html" target="_blank" rel="noopener">这个页面</a>浏览一下。</p>
<h3 id="默认首页：noir-content-getting-started"><a href="#默认首页：noir-content-getting-started" class="headerlink" title="默认首页：noir.content.getting-started"></a>默认首页：noir.content.getting-started</h3><p>我们在代码中并没有看到<code>(defpage &quot;/&quot; [] ...)</code>这样的定义，那为什么网站根目录会出现一个默认页面呢？答案在<code>noir.content.getting-started</code>这个命名空间中，可以<a href="https://github.com/noir-clojure/noir/blob/master/src/noir/content/getting_started.clj" target="_blank" rel="noopener">点击这里</a>查看它的源码。要取消这个默认页面，可以在welcome.clj的:require中将其删除。</p>
<h3 id="静态资源：src-resources-public"><a href="#静态资源：src-resources-public" class="headerlink" title="静态资源：src/resources/public"></a>静态资源：src/resources/public</h3><p>Noir默认对src/resources/public目录下的文件做了路由，因此当有一个资源文件位于src/resources/public/css/reset.css时，可以通过<a href="http://127.0.0.1:8080/css/reset.css访问。" target="_blank" rel="noopener">http://127.0.0.1:8080/css/reset.css访问。</a></p>
<p>值得一提的是，Noir项目本身依赖于两个开源项目：<a href="https://github.com/ring-clojure/ring" target="_blank" rel="noopener">ring</a>和<a href="https://github.com/weavejester/compojure/tree/master/src" target="_blank" rel="noopener">compojure</a>，前者对HTTP请求进行了封装，提供了一套类似Python WSGI的API；后者则是专门提供URL路由功能的类库。如对静态资源的路由，实质上Noir是调用了compojure提供的resources函数，函数中又调用ring提供的GET、wrap-file-info等函数响应请求。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章讲述了Clojure环境的搭建，特别是项目管理工具<code>lein</code>的一般使用。通过对Noir项目骨架的分析，我们一窥Clojure的语法，接触了变量、直接量、函数、宏、命名空间的一些用法，并能结合Noir和Hiccup写出简单的页面来。下一章我们将讲解如何使用Noir编写表单页面进行交互，以及Clojure如何连接数据库，对博文进行增删改查等操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://shzhangji.com/cnblogs/2012/11/25/cia-noir-1/" data-id="cjqaenxwj000a1wr4lqoammmc" class="article-share-link">分享</a>
      
        <a href="http://shzhangji.com/cnblogs/2012/11/25/cia-noir-1/#disqus_thread" class="article-comment-link">留言</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/cnblogs/tags/clojure/">clojure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/cnblogs/tags/noir/">noir</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/cnblogs/tags/tutorial/">tutorial</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/cnblogs/2012/12/08/cia-noir-2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          Clojure 实战(2)：使用 Noir 框架开发博客(中)
        
      </div>
    </a>
  
  
    <a href="/cnblogs/2012/11/18/aosa-python-packaging/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">开源软件架构 - 卷1：第14章 Python 打包工具</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Python数据平台</h3>
    <div class="widget">
      <img src="/cnblogs/images/pydp-qrcode.jpg" style="width: 100%;"></img>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/cnblogs/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/cnblogs/tags/analytics/" style="font-size: 15px;">analytics</a> <a href="/cnblogs/tags/angular/" style="font-size: 10px;">angular</a> <a href="/cnblogs/tags/aop/" style="font-size: 10px;">aop</a> <a href="/cnblogs/tags/aosa/" style="font-size: 11.25px;">aosa</a> <a href="/cnblogs/tags/apache-beam/" style="font-size: 10px;">apache beam</a> <a href="/cnblogs/tags/bootstrap/" style="font-size: 10px;">bootstrap</a> <a href="/cnblogs/tags/c/" style="font-size: 10px;">c</a> <a href="/cnblogs/tags/canal/" style="font-size: 10px;">canal</a> <a href="/cnblogs/tags/cdh/" style="font-size: 10px;">cdh</a> <a href="/cnblogs/tags/clojure/" style="font-size: 17.5px;">clojure</a> <a href="/cnblogs/tags/crossfilter/" style="font-size: 10px;">crossfilter</a> <a href="/cnblogs/tags/data-science/" style="font-size: 10px;">data science</a> <a href="/cnblogs/tags/dc-js/" style="font-size: 10px;">dc.js</a> <a href="/cnblogs/tags/docker/" style="font-size: 10px;">docker</a> <a href="/cnblogs/tags/druid/" style="font-size: 10px;">druid</a> <a href="/cnblogs/tags/eclipse/" style="font-size: 10px;">eclipse</a> <a href="/cnblogs/tags/es6/" style="font-size: 10px;">es6</a> <a href="/cnblogs/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/cnblogs/tags/etl/" style="font-size: 13.75px;">etl</a> <a href="/cnblogs/tags/flink/" style="font-size: 10px;">flink</a> <a href="/cnblogs/tags/flume/" style="font-size: 12.5px;">flume</a> <a href="/cnblogs/tags/frontend/" style="font-size: 12.5px;">frontend</a> <a href="/cnblogs/tags/functional-programming/" style="font-size: 10px;">functional programming</a> <a href="/cnblogs/tags/git/" style="font-size: 11.25px;">git</a> <a href="/cnblogs/tags/hadoop/" style="font-size: 12.5px;">hadoop</a> <a href="/cnblogs/tags/hbase/" style="font-size: 10px;">hbase</a> <a href="/cnblogs/tags/hdfs/" style="font-size: 11.25px;">hdfs</a> <a href="/cnblogs/tags/hive/" style="font-size: 13.75px;">hive</a> <a href="/cnblogs/tags/java/" style="font-size: 18.75px;">java</a> <a href="/cnblogs/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/cnblogs/tags/jvm/" style="font-size: 10px;">jvm</a> <a href="/cnblogs/tags/kafka/" style="font-size: 11.25px;">kafka</a> <a href="/cnblogs/tags/lodash/" style="font-size: 10px;">lodash</a> <a href="/cnblogs/tags/machine-learning/" style="font-size: 11.25px;">machine learning</a> <a href="/cnblogs/tags/mapreduce/" style="font-size: 11.25px;">mapreduce</a> <a href="/cnblogs/tags/mysql/" style="font-size: 11.25px;">mysql</a> <a href="/cnblogs/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/cnblogs/tags/noir/" style="font-size: 12.5px;">noir</a> <a href="/cnblogs/tags/opensource/" style="font-size: 10px;">opensource</a> <a href="/cnblogs/tags/ops/" style="font-size: 11.25px;">ops</a> <a href="/cnblogs/tags/pandas/" style="font-size: 11.25px;">pandas</a> <a href="/cnblogs/tags/perl/" style="font-size: 11.25px;">perl</a> <a href="/cnblogs/tags/python/" style="font-size: 18.75px;">python</a> <a href="/cnblogs/tags/react/" style="font-size: 10px;">react</a> <a href="/cnblogs/tags/restful/" style="font-size: 10px;">restful</a> <a href="/cnblogs/tags/scala/" style="font-size: 12.5px;">scala</a> <a href="/cnblogs/tags/source-code/" style="font-size: 10px;">source code</a> <a href="/cnblogs/tags/spark/" style="font-size: 16.25px;">spark</a> <a href="/cnblogs/tags/spark-streaming/" style="font-size: 10px;">spark streaming</a> <a href="/cnblogs/tags/spring/" style="font-size: 12.5px;">spring</a> <a href="/cnblogs/tags/sql/" style="font-size: 11.25px;">sql</a> <a href="/cnblogs/tags/storm/" style="font-size: 10px;">storm</a> <a href="/cnblogs/tags/stream-processing/" style="font-size: 13.75px;">stream processing</a> <a href="/cnblogs/tags/tensorflow/" style="font-size: 10px;">tensorflow</a> <a href="/cnblogs/tags/thrift/" style="font-size: 10px;">thrift</a> <a href="/cnblogs/tags/translation/" style="font-size: 20px;">translation</a> <a href="/cnblogs/tags/tutorial/" style="font-size: 17.5px;">tutorial</a> <a href="/cnblogs/tags/unix/" style="font-size: 10px;">unix</a> <a href="/cnblogs/tags/vue/" style="font-size: 10px;">vue</a> <a href="/cnblogs/tags/vuex/" style="font-size: 10px;">vuex</a> <a href="/cnblogs/tags/websocket/" style="font-size: 10px;">websocket</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2015/03/">三月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2014/12/">十二月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2014/11/">十一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2014/10/">十月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2014/07/">七月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2014/04/">四月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2013/06/">六月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2013/05/">五月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2013/04/">四月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2013/03/">三月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2013/02/">二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2013/01/">一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2012/12/">十二月 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/cnblogs/archives/2012/11/">十一月 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/cnblogs/2018/12/30/real-time-exactly-once-etl-with-apache-flink/">使用 Apache Flink 开发实时 ETL</a>
          </li>
        
          <li>
            <a href="/cnblogs/2018/12/09/spark-datasource-api-v2/">Spark DataSource API V2</a>
          </li>
        
          <li>
            <a href="/cnblogs/2018/10/04/flume-source-code-hdfs-sink/">Flume 源码解析：HDFS Sink</a>
          </li>
        
          <li>
            <a href="/cnblogs/2018/09/22/how-to-avoid-null-pointer-exception/">Java 空指针异常的若干解决方案</a>
          </li>
        
          <li>
            <a href="/cnblogs/2018/09/14/is-it-necessary-to-apply-eslint-jsx-no-bind-rule/">是否需要使用 ESLint jsx-no-bind 规则？</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="https://mirrors.creativecommons.org/presskit/buttons/80x15/svg/by-nc-sa.svg"></a>
      <br>
      &copy; 2018 张吉<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/cnblogs/" class="mobile-nav-link">首页</a>
  
    <a href="/cnblogs/categories/Big-Data" class="mobile-nav-link">大数据</a>
  
    <a href="/cnblogs/categories/Programming" class="mobile-nav-link">编程</a>
  
    <a href="/cnblogs/categories/Digest" class="mobile-nav-link">摘译</a>
  
    <a href="/cnblogs/archives" class="mobile-nav-link">全部文章</a>
  
    <a href="http://shzhangji.com/" class="mobile-nav-link">English</a>
  
</nav>
    
<script>
  var disqus_shortname = 'jizhang';
  
  var disqus_url = 'http://shzhangji.com/cnblogs/2012/11/25/cia-noir-1/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/cnblogs/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/cnblogs/fancybox/jquery.fancybox.css">
  <script src="/cnblogs/fancybox/jquery.fancybox.pack.js"></script>


<script src="/cnblogs/js/script.js"></script>

  </div>
</body>
</html>